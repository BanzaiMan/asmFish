.macro Search PvNode, RootNode
Search.tte                      = 0
Search.ltte                     = 1*sizeof.rq + Search.tte
Search.posKey                   = 1*sizeof.rq + Search.ltte
Search.ttMove                   = 1*sizeof.rq + Search.posKey
Search.ttValue                  = 1*sizeof.rd + Search.ttMove
Search.move 	                 = 1*sizeof.rd + Search.ttValue
Search.excludedMove             = 1*sizeof.rd + Search.move
Search.bestMove                 = 1*sizeof.rd + Search.excludedMove
Search.ext                      = 1*sizeof.rd + Search.bestMove
Search.newDepth     	       = 1*sizeof.rd + Search.ext
Search.predictedDepth	       = 1*sizeof.rd + Search.newDepth
Search.moveCount                = 1*sizeof.rd + Search.predictedDepth
Search.quietCount               = 1*sizeof.rd + Search.moveCount
Search.alpha                    = 1*sizeof.rd + Search.quietCount
Search.beta                     = 1*sizeof.rd + Search.alpha
Search.depth                    = 1*sizeof.rd + Search.beta
Search.bestValue                = 1*sizeof.rd + Search.depth
Search.value                    = 1*sizeof.rd + Search.bestValue
Search.eval                     = 1*sizeof.rd + Search.value
Search.nullValue                = 1*sizeof.rd + Search.eval
Search.futilityValue            = 1*sizeof.rd + Search.nullValue
Search.extension                = 1*sizeof.rd + Search.futilityValue
Search.success                  = 1*sizeof.rd + Search.extension
Search.rbeta                    = 1*sizeof.rd + Search.success
Search.moved_piece_to_sq        = 1*sizeof.rd + Search.rbeta
Search.reductionOffset          = 1*sizeof.rd + Search.moved_piece_to_sq
Search.skipQuiets               = 1*sizeof.rd + Search.reductionOffset
Search.singularExtensionNode    = 1*sizeof.rb + Search.skipQuiets
Search.improving                = 1*sizeof.rb + Search.singularExtensionNode
Search.captureOrPromotion       = 1*sizeof.rb + Search.improving
Search.doFullDepthSearch        = 1*sizeof.rb + Search.captureOrPromotion
Search.cutNode                  = 1*sizeof.rb + Search.doFullDepthSearch
Search.ttHit                    = 1*sizeof.rb + Search.cutNode
Search.moveCountPruning         = 1*sizeof.rb + Search.ttHit
Search.ttCapture                = 1*sizeof.rb + Search.moveCountPruning
Search.__1                      = 1*sizeof.rd + Search.ttCapture
Search.quietsSearched           = 1*sizeof.rd + Search.__1
  .if \PvNode == 1
Search.pv                       = 64*sizeof.rd          + Search.quietsSearched
Search.lend                     = (MAX_PLY+1)*sizeof.rd + Search.pv
  .else
Search.lend                     = 64*sizeof.rd          + Search.quietsSearched
  .endif
Search.localsize = (Search.lend + 15) & -16

                stp  x21, x22, [sp, -16]!
                stp  x23, x24, [sp, -16]!
                stp  x25, x26, [sp, -16]!
                stp  x27, x28, [sp, -16]!
                stp  x29, x30, [sp, -16]!
                sub  sp, sp, Search.localsize
                str  w1, [sp, Search.alpha]
                str  w2, [sp, Search.beta]
                str  w8, [sp, Search.depth]
               strb  w9, [sp, Search.cutNode]

Display 2, "Search(alpha=%i1, beta=%i2, depth=%i8, cutNode=%i9) called\n"

                mov  w0, 0
                str  w0, [sp, Search.moveCount]
                str  w0, [sp, Search.quietCount]
                str  w0, [x21, State.moveCount]
                str  w0, [x21, State.history]
                mov  w4, -VALUE_INFINITE
                str  w4, [sp, Search.bestValue]
               ldrb  w22, [x21, -1*sizeof.State + State.ply]
                add  w22, w22, 1
               strb  w22, [x21, State.ply]

  .if \PvNode == 1
                add  x6, x20, -Thread.rootPos
               ldrb  w0, [x6, Thread.selDepth]
                cmp  w0, w22
               csel  w0, w22, w0, lo
               strb  w0, [x6, Thread.selDepth]
 .endif        


        // callsCnt counts down as in master
        // resetCnt, if nonzero, contains the count to which callsCnt should be reset
                add  x6, x20, -Thread.rootPos
                ldr  w0, [x6, Thread.resetCnt]
                add  x6, x20, -Thread.rootPos
                ldr  w2, [x6, Thread.callsCnt]
                cbz  w0, Search.dontreset\@
                mov  w2, w0
                add  x6, x20, -Thread.rootPos
                str  wzr, [x6, Thread.resetCnt]
Search.dontreset\@:
               subs  w2, w2, 1
                add  x6, x20, -Thread.rootPos
                str  w2, [x6, Thread.callsCnt]
                bpl  Search.dontchecktime\@
                 bl  CheckTime  // CheckTime sets resetCalls for all threads
Search.dontchecktime\@:


  .if \RootNode == 0
        // Step 2. check for aborted search and immediate draws
               ldrh  w2, [x21, State.rule50]
               ldrh  w1, [x21, State.pliesFromNull]
                ldr  x8, [x21, State.key]
                mov  w0, w22
                cmp  w22, MAX_PLY
                bhs  Search.AbortSearch_PlyBigger\@
                lea  x6, signals + Signals.stop
               ldrb  w4, [x6]
               cbnz  w4, Search.AbortSearch_PlySmaller\@

        // ss->ply < MAX_PLY holds at this point, so if we should
        //   go to .AbortSearch_PlySmaller if a draw is detected
          PosIsDraw  Search.AbortSearch_PlySmaller\@, Search.CheckDraw_Cold\@, Search.CheckDraw_ColdRet\@


        // Step 3. mate distance pruning
                ldr  w1, [sp, Search.alpha]
                ldr  w2, [sp, Search.beta]
                mov  w4, VALUE_MATE
                sub  w0, w22, w4
                cmp  w1, w0
               csel  w1, w0, w1, lt
                mvn  w0, w0
                cmp  w2, w0
               csel  w2, w0, w2, gt
                str  w1, [sp, Search.alpha]
                str  w2, [sp, Search.beta]
                mov  w0, w1
                cmp  w1, w2
                bge  Search.Return\@
  .endif

                mov  w0, 0
                mov  w1, CmhDeadOffset
                ldr  x4, [x20, Pos.counterMoveHistory]
                add  x1, x1, x4
                str  w0, [sp, Search.bestMove]
                str  w0, [x21, 1*sizeof.State + State.excludedMove]
                str  w0, [x21, 0*sizeof.State + State.currentMove]
                str  x1, [x21, 0*sizeof.State + State.counterMoves]
               strb  w0, [x21, 1*sizeof.State + State.skipEarlyPruning]
                str  x0, [x21, 2*sizeof.State + State.killers]

        // Step 4. transposition table look up
                ldr  w1, [x21, State.excludedMove]
                str  w1, [sp, Search.excludedMove]
                ldr  x4, [x21, State.key]
                eor  x1, x1, x4
                str  x1, [sp, Search.posKey]
                 bl  MainHash_Probe

                str  x0, [sp, Search.tte]
                str  x1, [sp, Search.ltte]
               strb  w2, [sp, Search.ttHit]
                asr  x27, x1, 48
               sbfx  w0, w1, 8, 8
                mov  w23, w2
  .if \RootNode == 0
                lsr  w1, w1, 16
  .else
                add  x6, x20, -Thread.rootPos
                ldr  w1, [x6, Thread.PVIdx]
                mov  w4, sizeof.RootMove
                mul  w1, w1, w4
                ldr  x4, [x20, Pos.rootMovesVec + RootMovesVec.table]
                add  x1, x1, x4
                ldr  w1, [x1, RootMove.pv + 4*0]
 .endif
                str  w1, [sp, Search.ttMove]
                //str  w27, [Search.ttValue]

                mov  w4, VALUE_MATE_IN_MAX_PLY
                add  w8, w27, w4
                cbz  w2, Search.DontReturnTTValue\@

                mov  w4, VALUE_NONE
                cmp  w27, w4
                beq  Search.DontReturnTTValue\@

                mov  w4, VALUE_MATE_IN_MAX_PLY
                cmp  w8, w4, lsl 1
                bhs  Search.ValueFromTT\@
Search.ValueFromTTRet\@:

  .if \PvNode == 0
                ldr  w4, [sp, Search.depth]
                cmp  w0, w4
                blt  Search.DontReturnTTValue\@
                mov  w0, BOUND_UPPER
                mov  w8, BOUND_LOWER
                ldr  w4, [sp, Search.beta]
                cmp  w27, w4
               csel  w0, w8, w0, ge
               ldrb  w4, [sp, Search.ltte+MainHashEntry.genBound]
                tst  w0, w4
                bne  Search.ReturnTTValue\@
  .endif

Search.DontReturnTTValue\@:
                str  w27, [sp, Search.ttValue]


        // step 5. evaluate the position statically
                mov  w0, VALUE_NONE
                str  w0, [sp, Search.eval]
                str  w0, [x21, State.staticEval]
                ldr  x1, [x21, State.checkersBB]
               cbnz  x1, Search.moves_loop\@
                ldr  w2, [x21, -1*sizeof.State + State.currentMove]
              ldrsh  w0, [sp, Search.ltte + MainHashEntry.eval]
               cbnz  w23, Search.StaticValueYesTTHit\@
Search.StaticValueNoTTHit\@:

                ldr  w0, [x21, -1*sizeof.State + State.staticEval]
                neg  w0, w0
                add  w0, w0, 2*Eval_Tempo
                ldr  x22, [sp, Search.tte]
                mov  w4, MOVE_NULL
                cmp  w2, w4
                beq  1f
                 bl  Evaluate
        1:      mov  w8, w0
                str  w0, [x21, State.staticEval]
                str  w0, [sp, Search.eval]
                ldr  x9, [sp, Search.posKey]
                lsr  x9, x9, 48
                mov  w2, VALUE_NONE
                mov  w3, BOUND_NONE
                mov  w5, DEPTH_NONE
                mov  w0, 0
                MainHash_Save  Search.ltte, x22, w9, w2, w3, w5, w0, w8
                  b  Search.StaticValueDone\@
Search.StaticValueYesTTHit\@:

                mov  w4, VALUE_NONE
                cmp  w0, w4
                bne  1f
                 bl  Evaluate
        1:      mov  w1, 0
                str  w0, [x21, State.staticEval]
                cmp  w27, w0
               cset  w1, gt
                add  w1, w1, BOUND_UPPER
                mov  w4, VALUE_NONE
                cmp  w27, w4
                beq  1f
               ldrb  w4, [sp, Search.ltte + MainHashEntry.genBound]
                tst  w1, w4
               csel  w0, w27, w0, ne
        1:      str  w0, [sp, Search.eval]
        Search.StaticValueDone\@:

               ldrb  w0, [x21, State.skipEarlyPruning]
               cbnz  w0, Search.moves_loop\@

        // Step 6. Razoring (skipped when in check)
  .if \PvNode == 0
                ldr  w2, [sp, Search.depth]
                cmp  w2, 4*ONE_PLY
                bge  Search.6skip\@
                ldr  w1, [sp, Search.eval]
                lea  x6, RazorMargin
                ldr  w0, [x6, x2, lsl 2]
                add  w0, w0, w1
                ldr  w4, [sp, Search.alpha]
                cmp  w0, w4
                bgt  Search.6skip\@
                ldr  w1, [sp, Search.alpha]
                mov  w8, 0
                cmp  w2, ONE_PLY
                bgt  Search.6b\@
Search.6a\@:
                ldr  w2, [sp, Search.beta]
                 bl  QSearch_NonPv_NoCheck
                  b  Search.Return\@
Search.6b\@:
                lea  x6, RazorMargin
                ldr  w4, [x6, x2, lsl 2]
                sub  w1, w1, w4
                add  w2, w1, 1
                mov  w26, w1
                 bl  QSearch_NonPv_NoCheck
                cmp  w0, w26
                ble  Search.Return\@
Search.6skip\@:
 .endif


        // Step 7. Futility pruning: child node (skipped when in check)
 .if \RootNode == 0
                ldr  w2, [sp, Search.depth]
                ldr  w1, [x20, Pos.sideToMove]
                cmp  w2, 7*ONE_PLY
                bge  Search.7skip\@
                mov  w4, -150
                mul  w2, w2, w4
                ldr  w0, [sp, Search.eval]
                mov  w4, VALUE_KNOWN_WIN
                cmp  w0, w4
                bge  Search.7skip\@
                add  w2, w2, w0
                ldr  w4, [sp, Search.beta]
                cmp  w2, w4
                blt  Search.7skip\@
                add  x6, x21, x1, lsl 1
               ldrh  w1, [x6, State.npMaterial]
               cbnz  w1, Search.Return\@
Search.7skip\@:
 .endif


                // Step 8. Null move search with verification search (is omitted in PV nodes)
  .if \PvNode == 0
                ldr  w2, [sp, Search.depth]
                mov  w4, 35
                mul  w0, w2, w4
                ldr  w4, [x21, State.staticEval]
                add  w0, w0, w4
                ldr  w26, [sp, Search.beta]
                ldr  w1, [x20, Pos.sideToMove]
                ldr  w4, [sp, Search.eval]
                cmp  w26, w4
                bgt  Search.8skip\@
                add  w26, w26, 35*6
                add  x6, x21, State.npMaterial
               ldrh  w1, [x6, x1, lsl 1]
                cbz  w1, Search.8skip\@
                sub  w2, w2, 13*ONE_PLY
                sub  w0, w0, w26
               ands  w2, w2, w0
                bmi  Search.8skip\@
Search.8do\@:
                mov  w0, CmhDeadOffset
                ldr  x4, [x20, Pos.counterMoveHistory]
                add  x0, x0, x4
                mov  w4, MOVE_NULL
                str  w4, [x21, State.currentMove]
                str  x0, [x21, State.counterMoves]

                ldr  w0, [sp, Search.eval]
                ldr  w4, [sp, Search.beta]
                sub  w0, w0, w4
                mov  w1, PawnValueMg
               sdiv  x0, x0, x1
                mov  w1, 3
                cmp  w0, w1
               csel  w0, w1, w0, gt
                ldr  w1, [sp, Search.depth]
                mov  w4, 67
                mul  w1, w1, w4
                add  w1, w1, 823
                asr  w1, w1, 8
                add  w0, w0, w1

                ldr  w26, [sp, Search.depth]
                sub  w26, w26, w0
        // esi = depth-R
                 bl  Move_DoNull
                mov  w4, -1
               strb  w4, [x21, State.skipEarlyPruning]
                mov  w8, w26
                mov  w0, 0
                adr  x22, QSearch_NonPv_NoCheck
                adr  x1, Search_NonPv
                cmp  w26, ONE_PLY
               csel  x22, x1, x22, ge
               csel  w8, w0, w8, lt
                ldr  w1, [sp, Search.beta]
                neg  w1, w1
                add  w2, w1, 1
               ldrb  w9, [sp, Search.cutNode]
                mvn  w9, w9
                blr  x22
                neg  w0, w0
               strb  wzr, [x21, State.skipEarlyPruning]
                ldr  w4, [x20, Pos.sideToMove]
                eor  w4, w4, 1
                str  w4, [x20, Pos.sideToMove]
                sub  x21, x21, sizeof.State

                ldr  w2, [sp, Search.beta]
                cmp  w0, w2
                blt  Search.8skip\@

                mov  w4, VALUE_MATE_IN_MAX_PLY
                cmp  w0, w4
               csel  w0, w2, w0, ge
                mov  w27, w0
        // edi = nullValue

                ldr  w1, [sp, Search.depth]
                cmp  w1, 12*ONE_PLY
                bge  Search.8check\@
                mov  w4, VALUE_KNOWN_WIN-1
                add  w1, w2, w4
                mov  w4, VALUE_KNOWN_WIN-1
                cmp  w1, w4, lsl 1
                bls  Search.Return\@
Search.8check\@:
                mov  w4, -1
               strb  w4, [x21, State.skipEarlyPruning]
                mov  w8, w26
                mov  w0, 0
                adr  x22, QSearch_NonPv_NoCheck
                adr  x1, Search_NonPv
                cmp  w26, ONE_PLY
               csel  x22, x1, x22, ge
               csel  w8, w0, w8, lt 
                sub  w1, w2, 1
                mov  w9, 0
                blr  x22
               strb  wzr, [x21, State.skipEarlyPruning]
                ldr  w4, [sp, Search.beta]
                cmp  w0, w4
                mov  w0, w27
                bge  Search.Return\@
Search.8skip\@:
  .endif


        // Step 9. ProbCut (skipped when in check)
  .if \PvNode == 0
                ldr  w0, [sp, Search.depth]
                cmp  w0, 5*ONE_PLY
                blt  Search.9skip\@
                ldr  w0, [sp, Search.beta]
                mov  w4, VALUE_MATE_IN_MAX_PLY-1
                add  w0, w0, w4
                mov  w4, VALUE_MATE_IN_MAX_PLY-1
                cmp  w0, w4, lsl 1
                bhi  Search.9skip\@

                ldr  w27, [sp, Search.beta]
                add  w27, w27, 200
                mov  w0, VALUE_INFINITE
                cmp  w27, w0
               csel  w27, w0, w27, gt
                str  w27, [sp, Search.rbeta]
                ldr  w4, [x21, State.staticEval]
                sub  w27, w27, w4

        // initialize movepick
                adr  x25, MovePick_PROBCUT_GEN
                str  w27, [x21, State.threshold]
                ldr  w1, [sp, Search.ttMove]
                mov  w0, w1
                mov  w2, w1
                and  w2, w2, 63
                lsr  w0, w0, 12
                add  x6, x20, Pos.board
               ldrb  w2, [x6, x2]
                mov  w27, 0
                cbz  w1, Search.9NoTTMove\@
                cmp  w0, MOVE_TYPE_CASTLE
                beq  Search.9NoTTMove\@
                cmp  w0, MOVE_TYPE_EPCAP
                beq  1f
                cbz  w2, Search.9NoTTMove\@
        1:      ldr  w1, [sp, Search.ttMove]
                 bl  Move_IsPseudoLegal
                cbz  x0, Search.9NoTTMove\@
                ldr  w1, [sp, Search.ttMove]
                ldr  w2, [x21, State.threshold]
                 bl  SeeTestGe
                cbz  w0, Search.9NoTTMove\@
                ldr  w27, [sp, Search.ttMove]
                adr  x25, MovePick_PROBCUT
Search.9NoTTMove\@:
                str  x25, [x21, State.stage]
                str  w27, [x21, State.ttMove]

Search.9moveloop\@:
                mov  w26, 0
        GetNextMove
                str  w0, [sp, Search.move]

                mov  w1, w0
                cbz  w0, Search.9moveloop_done\@
                 bl  Move_IsLegal
                cbz  w0, Search.9moveloop\@

                ldr  w1, [sp, Search.move]
                str  w1, [x21, State.currentMove]

               ubfx  w0, w1, 6, 6
                and  w1, w1, 63
                add  x6, x20, Pos.board
               ldrb  w0, [x6, x0]
                add  w0, w1, w0, lsl 6
                ldr  x4, [x20, Pos.counterMoveHistory]
                add  x0, x4, x0, lsl 12
                str  x0, [x21, State.counterMoves]

                ldr  w1, [sp, Search.move]
                 bl  Move_GivesCheck
                ldr  w1, [sp, Search.move]
               strb  w0, [x21, State.givesCheck]
                 bl  Move_Do__ProbCut
                ldr  w1, [sp, Search.rbeta]
                mov  w27, w1
                neg  w1, w1
                add  w2, w1, 1
                ldr  w8, [sp, Search.depth]
                sub  w8, w8, 4*ONE_PLY
               ldrb  w9, [sp, Search.cutNode]
                mvn  w9, w9
                 bl  Search_NonPv
                neg  w0, w0
                mov  w26, w0
                ldr  w1, [sp, Search.move]
                 bl  Move_Undo
                mov  w0, w26
                cmp  w26, w27
                blt  Search.9moveloop\@
                  b  Search.Return\@

Search.9moveloop_done\@:
Search.9skip\@:
  .endif


        // Step 10. Internal iterative deepening (skipped when in check)
                ldr  w8, [sp, Search.depth]
                ldr  w1, [sp, Search.ttMove]
               cbnz  w1, Search.10skip\@
                cmp  w8, 6*ONE_PLY
                blt  Search.10skip\@
                add  w8, w8, w8, lsl 1
                asr  w8, w8, 2
                sub  w8, w8, 2*ONE_PLY
         .if \PvNode == 1
                ldr  w1, [sp, Search.alpha]
                ldr  w2, [sp, Search.beta]
               ldrb  w9, [sp, Search.cutNode]
                mov  w4, -1
               strb  w4, [x21, State.skipEarlyPruning]
                 bl  Search_Pv
         .else
                ldr  w0, [x21, State.staticEval]
                add  w0, w0, 256
                ldr  w4, [sp, Search.beta]
                cmp  w0, w4
                blt  Search.10skip\@
                ldr  w1, [sp, Search.alpha]
                ldr  w2, [sp, Search.beta]
               ldrb  w9, [sp, Search.cutNode]
                mov  w4, -1
               strb  w4, [x21, State.skipEarlyPruning]
                 bl  Search_NonPv
         .endif
               strb  wzr, [x21, State.skipEarlyPruning]
                ldr  x1, [sp, Search.posKey]
                 bl  MainHash_Probe
                str  x0, [sp, Search.tte]
                str  x1, [sp, Search.ltte]
               strb  w2, [sp, Search.ttHit]
                lsr  w1, w1, 16
                str  w1, [sp, Search.ttMove]

Search.10skip\@:



Search.moves_loop\@:    // this is actually not the head of the loop

        // The data at tte could have been changed by
        //   Step 6. Razoring
        //   Step 9. ProbCut
        // Note that after
        //   Step 10. Internal iterative deepening
        // the data is reloaded
        // Also, in the case of a tt miss, tte points to junk but must be used anyways.
        // We reload the data in .ltte for its use in .singularExtensionNode.
                ldr  x0, [sp, Search.tte]
                ldr  x0, [x0]
                str  x0, [sp, Search.ltte]


        // initialize move pick
                ldr  w1, [sp, Search.ttMove]
                ldr  w2, [sp, Search.depth]

                str  w2, [x21, State.depth]

                ldr  x27, [x20, Pos.counterMoves]
                ldr  w0, [x21, -1*sizeof.State + State.currentMove]
                and  w0, w0, 63
                add  x6, x20, Pos.board
               ldrb  w2, [x6, x0]
                add  w2, w0, w2, lsl 6
                ldr  w0, [x27, x2, lsl 2]
                str  w0, [x21, State.countermove]

                adr  x25, MovePick_CAPTURES_GEN
                adr  x24, MovePick_ALL_EVASIONS
                mov  w27, w1
                cbz  w1, Search.NoTTMove\@
                 bl  Move_IsPseudoLegal

                tst  x0, x0
               csel  w27, w0, w27, eq
                beq  Search.NoTTMove\@
                adr  x25, MovePick_MAIN_SEARCH
                adr  x24, MovePick_EVASIONS
Search.NoTTMove\@:
                ldr  x8, [x21, State.checkersBB]
                ldr  x0, [x21, State.killers]
                tst  x8, x8
               csel  x25, x24, x25, ne
                str  x0, [x21, State.mpKillers]
                str  w27, [x21, State.ttMove]
                str  x25, [x21, State.stage]

                ldr  w0, [sp, Search.bestValue]
                str  w0, [sp, Search.value]

                ldr  w2, [x21, -0*sizeof.State + State.staticEval]
                add  x6, x21, -2*sizeof.State
                ldr  w1, [x6, State.staticEval]
                cmp  w2, w1
               cset  w0, ge
                mov  w4, VALUE_NONE
                cmp  w2, w4
               cset  w2, eq
                mov  w4, VALUE_NONE
                cmp  w1, w4
               cset  w1, eq
                orr  w0, w0, w2
                orr  w0, w0, w1
               strb  w0, [sp, Search.improving]

                mov  w26, 63
               ldrb  w0, [sp, Search.improving]
                ldr  w2, [sp, Search.depth]
                mov  w1, w2
                cmp  w2, w26
               csel  w1, w26, w1, hi

                add  w0, w1, w0, lsl 6
                lsl  w0, w0, 6
                str  w0, [sp, Search.reductionOffset]

               strb  wzr, [sp, Search.skipQuiets]
                str  wzr, [sp, Search.ttCapture]
  .if \RootNode == 1
               strb  wzr, [sp, Search.singularExtensionNode]
  .else
                ldr  w1, [sp, Search.depth]
                cmp  w1, 8*ONE_PLY
               cset  w0, ge
                ldr  w2, [sp, Search.ttMove]
                tst  w2, w2
               cset  w1, ne
                and  w0, w0, w1
                ldr  w2, [sp, Search.ttValue]
                mov  w4, VALUE_NONE
                cmp  w2, w4
               cset  w1, ne

                and  w0, w0, w1
                ldr  w2, [sp, Search.excludedMove]
                tst  w2, w2
               cset  w1, eq
                and  w0, w0, w1
               ldrb  w2, [sp, Search.ltte + MainHashEntry.genBound]
                tst  w2, BOUND_LOWER
               cset  w1, ne
                and  w0, w0, w1
              ldrsb  w2, [sp, Search.ltte + MainHashEntry.depth]
                add  w2, w2, 3*ONE_PLY
                ldr  w4, [sp, Search.depth]
                cmp  w2, w4
               cset  w1, ge
                and  w0, w0, w1
               strb  w0, [sp, Search.singularExtensionNode]
  .endif

// Step 11. Loop through moves
Search.MovePickLoop\@:

              ldrsb  w26, [sp, Search.skipQuiets]
        GetNextMove
                str  w0, [sp, Search.move]
                cbz  w0, Search.MovePickDone\@
                ldr  w4, [sp, Search.excludedMove]
                cmp  w0, w4
                beq  Search.MovePickLoop\@

 .if \RootNode == 1
                add  x6, x20, -Thread.rootPos
                ldr  w1, [x6, Thread.PVIdx]
                mov  w4, sizeof.RootMove
                mul  w1, w1, w4
                ldr  x4, [x20, Pos.rootMovesVec + RootMovesVec.table]
                add  x1, x1, x4
                ldr  x2, [x20, Pos.rootMovesVec + RootMovesVec.ender]
        1:
                cmp  x1, x2
                bhs  Search.MovePickLoop\@
                ldr  w4, [x1, RootMove.pv + 4*0]
                cmp  w0, w4
                add  x1, x1, sizeof.RootMove
                bne  1b
  .endif

                ldr  w0, [sp, Search.moveCount]
                add  w0, w0, 1
                str  w0, [x21, State.moveCount]
                str  w0, [sp, Search.moveCount]

                mov  w0, 0
  .if \PvNode == 1
                str  x0, [x21, 1*sizeof.State + State.pv]
  .endif
                str  w0, [sp, Search.extension]

  .if USE_CURRMOVE
    .if VERBOSE < 2
      .if \RootNode == 1
                add  x6, x20, -Thread.rootPos
                ldr  w0, [x6, Thread.idx]
               cbnz  w0, Search.PrintCurrentMoveRet\@
                 bl  Os_GetTime
                lea  x6, time + Time.startTime
                ldr  x4, [x6]
                sub  x0, x0, x4
                mov  w4, CURRMOVE_MIN_TIME
                cmp  w0, w4
                bhs  Search.PrintCurrentMove\@
Search.PrintCurrentMoveRet\@:
      .endif
    .endif
  .endif

                ldr  w1, [sp, Search.move]

               ubfx  w2, w1, 6, 6

                add  x6, x20, Pos.board
               ldrb  w2, [x6, x2]
                and  w0, w1, 63
                add  w2, w0, w2, lsl 6
                str  w2, [sp, Search.moved_piece_to_sq]
        // moved_piece_to_sq = index of [moved_piece][to_sq(move)]
                lsr  w1, w1, 14
                add  x6, x20, Pos.board
               ldrb  w0, [x6, x0]
                lea  x6, _CaptureOrPromotion_or
               ldrb  w4, [x6, x1]
                orr  w0, w0, w4
                lea  x6, _CaptureOrPromotion_and
               ldrb  w4, [x6, x1]
                and  w0, w0, w4
               strb  w0, [sp, Search.captureOrPromotion]

                ldr  w1, [sp, Search.move]
                 bl  Move_GivesCheck
               strb  w0, [x21, State.givesCheck]

                ldr  w27, [sp, Search.depth]
               ldrb  w1, [sp, Search.improving]
                lsl  w1, w1, 6
                lea  x6, FutilityMoveCounts
                add  x6, x6, x1
                ldr  w1, [x6, x27, lsl 2]
                ldr  w4, [sp, Search.moveCount]
                sub  w1, w1, w4
                sub  w1, w1, 1
                sub  w27, w27, 16*ONE_PLY
                and  w27, w27, w1
                asr  w27, w27, 31
               strb  w27, [sp, Search.moveCountPruning]

                mvn  w27, w27
                and  w27, w27, w0

        // Step 12. Extend checks
               ldrb  w0, [sp, Search.singularExtensionNode]
                ldr  w1, [sp, Search.move]
                cbz  w0, Search.12else\@
                ldr  w4, [sp, Search.ttMove]
                cmp  w1, w4
                bne  Search.12else\@
                 bl  Move_IsLegal
                ldr  w2, [sp, Search.ttValue]
                ldr  w8, [sp, Search.depth]
               ldrb  w9, [sp, Search.cutNode]
                cbz  w0, Search.12else\@
                mov  w0, -VALUE_MATE
                sub  w2, w2, w8, lsl 1
                cmp  w2, w0
               csel  w2, w0, w2, lt
                sub  w1, w2, 1
                mov  w27, w2
                asr  w8, w8, 1
                ldr  w0, [sp, Search.move]
                str  w0, [x21, State.excludedMove]
                mov  w4, -1
               strb  w4, [x21, State.skipEarlyPruning]
        // The call to search_NonPV with the same value of ss messed up our
        // move picker data. So we fix it.
                ldr  x22, [x21, State.stage]
                ldr  x23, [x21, State.ttMove]   // ttMove and Depth
                ldr  x24, [x21, State.countermove]      // counter move and gives check
                ldr  x25, [x21, State.mpKillers]
                 bl  Search_NonPv
                mov  w1, 0
               strb  w1, [x21, State.skipEarlyPruning]
                str  w1, [x21, State.excludedMove]
                cmp  w0, w27
               cset  w1, lt
                str  w1, [sp, Search.extension]
        // The call to search_NonPV with the same value of ss messed up our
        // move picker data. So we fix it.
                str  x22, [x21, State.stage]
                str  x23, [x21, State.ttMove]
                str  x24, [x21, State.countermove]
                str  x25, [x21, State.mpKillers]
                  b  Search.12done\@

Search.12else\@:
                ldr  w1, [sp, Search.move]
                cbz  w27, Search.12dont_extend\@
        SeeSignTest  Search.12extend_oneply\@
                cbz  w0, Search.12dont_extend\@
Search.12extend_oneply\@:
                mov  w4, 1
                str  w4, [sp, Search.extension]
Search.12dont_extend\@:
Search.12done\@:


        // Step 13. Pruning at shallow depth
                ldr  w23, [sp, Search.move]
               ubfx  w22, w23, 6, 6
                and  w23, w23, 63
                add  x6, x20, Pos.board
               ldrb  w24, [x6, x22]
               ldrb  w25, [x6, x23]

                ldr  w0, [sp, Search.extension]
                ldr  w2, [sp, Search.depth]
                sub  w0, w0, 1
                add  w0, w0, w2
                str  w0, [sp, Search.newDepth]
        // w2 = depth

  .if \RootNode == 0
                ldr  w8, [x20, Pos.sideToMove]
                ldr  w1, [sp, Search.bestValue]
               ldrh  w26, [x21, State.npMaterial + 2*0]
                add  w0, w0, w1
                mov  w4, VALUE_MATED_IN_MAX_PLY
                cmp  w1, w4
                ble  Search.13done\@
                add  x6, x21, State.npMaterial
               ldrh  w1, [x6, x8, lsl 1]
                cbz  w1, Search.13done\@
               ldrb  w0, [sp, Search.captureOrPromotion]
               ldrh  w1, [x21, State.npMaterial + 2*1]
                add  w26, w26, w1
               ldrb  w4, [x21, State.givesCheck]
                orr  w0, w0, w4
               cbnz  w0, Search.13else\@
                mov  w1, Pawn
                add  w1, w1, w8, lsl 3
                mov  w4, 5000
                cmp  w26, w4
                bhs  Search.13do\@
                cmp  w24, w1
                bne  Search.13do\@
                mov  w4, 56
                mul  w8, w8, w4
                eor  w8, w8, w22
                cmp  w8, SQ_A5
                bhs  Search.13else\@
Search.13do\@:
        // Move count based pruning
               ldrb  w0, [sp, Search.moveCountPruning]
               ldrb  w4, [sp, Search.skipQuiets]
                orr  w4, w4, w0
               strb  w4, [sp, Search.skipQuiets]
               cbnz  w0, Search.MovePickLoop\@

                ldr  w27, [sp, Search.newDepth]
                mov  w26, 63
                ldr  w1, [sp, Search.moveCount]
                cmp  w1, w26
               csel  w1, w26, w1, hi
                ldr  w4, [sp, Search.reductionOffset]
                add  w1, w1, w4
                lea  x6, Reductions + 4*(2*64*64*\PvNode)
                ldr  w4, [x6, x1, lsl 2]
                sub  w27, w27, w4
        // edi = lmrDepth

        // Countermoves based pruning
                add  x6, x21, -1*sizeof.State + State.counterMoves
                ldr  x8, [x6]
                add  x6, x21, -2*sizeof.State + State.counterMoves
                ldr  x9, [x6]
                add  x11, x23, x24, lsl 6
                ldr  w0, [x8, x11, lsl 2]
                ldr  w1, [x9, x11, lsl 2]
                cmp  w27, 3*ONE_PLY
                bge  Search.13DontSkip2\@
                and  w0, w0, w1
               tbnz  w0, 31, Search.MovePickLoop\@
Search.13DontSkip2\@:

        // Futility pruning: parent node
                mov  w2, 0
                cmp  w27, 7*ONE_PLY
                bgt  Search.13done\@
                beq  Search.13check_see\@
                tst  w27, w27
               csel  w27, w2, w27, mi
                mov  w0, 200
                mul  w0, w0, w27
                add  w0, w0, 256
                ldr  w4, [x21, State.checkersBB]
                cmp  w2, w4
                bne  Search.13check_see\@
                ldr  w4, [x21, State.staticEval]
                add  w0, w0, w4
                ldr  w4, [sp, Search.alpha]
                cmp  w0, w4
                ble  Search.MovePickLoop\@
Search.13check_see\@:
        // Prune moves with negative SEE at low depths
                ldr  w1, [sp, Search.move]
                mov  w2, -35
                mul  w2, w2, w27
                mul  w2, w2, w27
                 bl  SeeTestGe
                cbz  w0, Search.MovePickLoop\@
                  b  Search.13done\@
Search.13else\@:
                ldr  w1, [sp, Search.move]
                cmp  w2, 7*ONE_PLY
                bge  Search.13done\@
               ldrb  w4, [sp, Search.extension]
               cbnz  w4, Search.13done\@
                mov  w4, -PawnValueEg
                mul  w2, w2, w4
                 bl  SeeTestGe
                cbz  w0, Search.MovePickLoop\@
Search.13done\@:
  .endif

        // Speculative prefetch as early as possible
                ldr  x0, [x21, State.key]
                lea  x6, Zobrist_side
                ldr  x4, [x6]
                eor  x0, x0, x4
                lea  x6, Zobrist_Pieces
                add  x6, x6, x24, lsl 9
                ldr  x4, [x6, x22, lsl 3]
                eor  x0, x0, x4
                ldr  x4, [x6, x23, lsl 3]
                eor  x0, x0, x4
                lea  x6, Zobrist_Pieces
                add  x6, x6, x25, lsl 9
                ldr  x4, [x6, x23, lsl 3]
                eor  x0, x0, x4
                lea  x6, mainHash
                ldr  x4, [x6, MainHash.mask]
                and  x0, x0, x4
                lsl  x0, x0, 5
                ldr  x4, [x6, MainHash.table]
                add  x0, x0, x4
               prfm  PLDL1KEEP, [x0]

        // Check for legality just before making the move
  .if \RootNode == 0
                ldr  w1, [sp, Search.move]
                 bl  Move_IsLegal
                cbz  x0, Search.IllegalMove\@
  .endif

                ldr  w1, [sp, Search.move]
                ldr  w0, [sp, Search.moved_piece_to_sq]
                lsl  w0, w0, 12
                ldr  x4, [x20, Pos.counterMoveHistory]
                add  x0, x0, x4
                str  w1, [x21, State.currentMove]
                str  x0, [x21, State.counterMoves]

               ldrb  w4, [sp, Search.captureOrPromotion]
                tst  w4, w4
               cset  w0, ne
                ldr  w4, [sp, Search.ttMove]
                cmp  w1, w4
               cset  w2, eq
                and  w0, w0, w2
                ldr  w4, [sp, Search.ttCapture]
                orr  w4, w4, w0
                str  w4, [sp, Search.ttCapture]

        // Step 14. Make the move
                 bl  Move_Do__Search

        // Step 15. Reduced depth search (LMR)
                ldr  w2, [sp, Search.depth]
                ldr  w1, [sp, Search.moveCount]
                cmp  w2, 3*ONE_PLY
                blt  Search.15skip\@
                cmp  w1, 1
                bls  Search.15skip\@

               ldrb  w8, [sp, Search.captureOrPromotion]
                cbz  w8, 1f
               ldrb  w0, [sp, Search.moveCountPruning]
                cbz  w0, Search.15skip\@
        1:

                mov  w26, 63
                cmp  w1, w26
               csel  w1, w26, w1, hi
                ldr  w4, [sp, Search.reductionOffset]
                add  w1, w1, w4
                lea  x6, Reductions + 4*(2*64*64*\PvNode)
                ldr  w27, [x6, x1, lsl 2]

                cbz  w8, Search.15NotCaptureOrPromotion\@
                mov  w0, 0
                tst  w27, w27
               cset  w0, ne
                sub  w27, w27, w0
                  b  Search.15ReadyToSearch\@

Search.15NotCaptureOrPromotion\@:

        // r12d = from
        // r13d = to
        // r14d = from piece
        // r15d = to piece

        // Increase reduction if ttMove is a capture
                ldr  w4, [sp, Search.ttCapture]
                add  w27, w27, w4

        // Increase reduction for cut nodes
               ldrb  w4, [sp, Search.cutNode]
                cbz  w4, Search.15testA\@
                add  w27, w27, 2*ONE_PLY
                  b  Search.15skipA\@
Search.15testA\@:
                ldr  w1, [sp, Search.move]
                cmp  w1, MOVE_TYPE_PROM << 12
                bhs  Search.15skipA\@
                mov  w9, w22
                mov  w8, w23
                mov  w2, 0
                 bl  SeeTestGe.HaveFromTo
               cbnz  w0, Search.15skipA\@
                sub  w27, w27, 2*ONE_PLY
Search.15skipA\@:
                ldr  w1, [sp, Search.move]
                and  w1, w1, 64*64-1
                ldr  w2, [sp, Search.moved_piece_to_sq]
                add  x6, x21, -1*sizeof.State+State.counterMoves - 1*sizeof.State
                ldr  x9, [x6]
                add  x6, x21, -2*sizeof.State+State.counterMoves - 1*sizeof.State
                ldr  x10, [x6]
                add  x6, x21, -4*sizeof.State+State.counterMoves - 1*sizeof.State
                ldr  x11, [x6]
                ldr  w0, [x20, Pos.sideToMove]
                eor  w0, w0, 1
                lsl  w0, w0, 14
                ldr  x4, [x20, Pos.history]
                add  x0, x0, x4
                ldr  w0, [x0, x1, lsl 2]
                sub  w0, w0, 4000

                add  x6, x21, -2*sizeof.State
                ldr  w1, [x6, State.history]

                ldr  w4, [x9, x2, lsl 2]
                add  w0, w0, w4
                ldr  w4, [x10, x2, lsl 2]
                add  w0, w0, w4
                ldr  w4, [x11, x2, lsl 2]
                add  w0, w0, w4

                neg  w2, w0
                and  w2, w2, w1
                neg  w1, w1
                and  w1, w1, w0
                add  w27, w27, w2, asr 31
                sub  w27, w27, w1, asr 31

                str  w0, [x21, -1*sizeof.State + State.history]

                mov  w1, 20000
               sdiv  w0, w0, w1
               subs  w27, w27, w0
               csel  w27, wzr, w27, mi

Search.15ReadyToSearch\@:

                mov  w0, 1
                ldr  w8, [sp, Search.newDepth]
                sub  w8, w8, w27
                cmp  w8, w0
               csel  w8, w0, w8, lt
                mov  w27, w8

                ldr  w2, [sp, Search.alpha]
                neg  w2, w2
                sub  w1, w2, 1
                mov  w9, -1
                 bl  Search_NonPv
                neg  w0, w0
                str  w0, [sp, Search.value]

                ldr  w4, [sp, Search.alpha]
                cmp  w0, w4
                ble  Search.17entry\@
                ldr  w4, [sp, Search.newDepth]
                cmp  w27, w4
                beq  Search.15dontdofulldepthsearch\@

                mov  x9, 0
                ldr  w8, [sp, Search.newDepth]
                adr  x10, QSearch_NonPv_InCheck
                adr  x11, QSearch_NonPv_NoCheck
               ldrb  w4, [x21, -1*sizeof.State + State.givesCheck]
                tst  w4, w4
               csel  x11, x10, x11, ne
                adr  x0, Search_NonPv
                cmp  w8, 1
               csel  x0, x11, x0, lt
               csel  w8, w9, w8, lt
                ldr  w2, [sp, Search.alpha]
                neg  w2, w2
                sub  w1, w2, 1
               ldrb  w9, [sp, Search.cutNode]
                mvn  w9, w9
                blr  x0
                neg  w0, w0
                str  w0, [sp, Search.value]

                ldr  w4, [sp, Search.alpha]
                cmp  w0, w4
                ble  Search.17entry\@

Search.15dontdofulldepthsearch\@:
  .if \PvNode == 1
    .if \RootNode == 0
                ldr  w0, [sp, Search.value]
                ldr  w4, [sp, Search.beta]
                cmp  w0, w4
                bge  Search.17entry\@
    .endif
                add  x0, sp, Search.pv
                str  x0, [x21, State.pv]
                str  wzr, [x0]

                mov  x9, 0
                ldr  w8, [sp, Search.newDepth]
                adr  x10, QSearch_Pv_InCheck
                adr  x11, QSearch_Pv_NoCheck
               ldrb  w4, [x21, -1*sizeof.State + State.givesCheck]
                tst  w4, w4
               csel  x11, x10, x11, ne
                adr  x0, Search_Pv
                cmp  w8, 1
               csel  x0, x11, x0, lt
               csel  w8, w9, w8, lt
                ldr  w1, [sp, Search.beta]
                neg  w1, w1
                ldr  w2, [sp, Search.alpha]
                neg  w2, w2
                mov  w9, 0
                blr  x0
                neg  w0, w0
                str  w0, [sp, Search.value]
  .endif
                  b  Search.17entry\@

Search.15skip\@:

// Step 16. full depth search   this is for when step 15 is skipped
  .if \PvNode == 1
                ldr  w4, [sp, Search.moveCount]
                cmp  w4, 1
                bls  Search.DoFullPvSearch\@
  .endif

Search.FullDepthSearch\@:
                mov  x9, 0
                ldr  w8, [sp, Search.newDepth]
                adr  x10, QSearch_NonPv_InCheck
                adr  x11, QSearch_NonPv_NoCheck
               ldrb  w4, [x21, -1*sizeof.State + State.givesCheck]
                tst  w4, w4
               csel  x11, x10, x11, ne
                adr  x0, Search_NonPv
                cmp  w8, 1
               csel  x0, x11, x0, lt
               csel  w8, w9, w8, lt
                ldr  w2, [sp, Search.alpha]
                neg  w2, w2
                sub  w1, w2, 1
               ldrb  w9, [sp, Search.cutNode]
                mvn  w9, w9
                blr  x0
                neg  w0, w0
                mov  w27, w0
                str  w0, [sp, Search.value]

  .if \PvNode == 1
                ldr  w4, [sp, Search.alpha]
                cmp  w27, w4
                ble  Search.SkipFullPvSearch\@
    .if \RootNode == 0
                ldr  w4, [sp, Search.beta]
                cmp  w27, w4
                bge  Search.SkipFullPvSearch\@
    .endif

Search.DoFullPvSearch\@:
                add  x0, sp, Search.pv
                str  x0, [x21, State.pv]
                str  wzr, [x0]

                mov  x9, 0
                ldr  w8, [sp, Search.newDepth]
                adr  x10, QSearch_Pv_InCheck
                adr  x11, QSearch_Pv_NoCheck
               ldrb  w4, [x21, -1*sizeof.State + State.givesCheck]
                tst  w4, w4
               csel  x11, x10, x11, ne
                adr  x0, Search_Pv
                cmp  w8, 1
               csel  x0, x11, x0, lt
               csel  w8, w9, w8, lt
                ldr  w1, [sp, Search.beta]
                neg  w1, w1
                ldr  w2, [sp, Search.alpha]
                neg  w2, w2
                mov  w9, 0
                blr  x0
                neg  w0, w0
                mov  w27, w0
                str  w0, [sp, Search.value]
Search.SkipFullPvSearch\@:
  .endif


        // Step 17. Undo move
Search.17entry\@:
                ldr  w1, [sp, Search.move]
                 bl  Move_Undo


        // Step 18. Check for new best move
                ldr  w27, [sp, Search.value]
                mov  w0, 0
                lea  x6, signals + Signals.stop
               ldrb  w4, [x6]
               cbnz  w4, Search.Return\@

 .if \RootNode == 1
                ldr  w1, [sp, Search.move]
                ldr  x2, [x20, Pos.rootMovesVec + RootMovesVec.table]
                sub  x2, x2, sizeof.RootMove
Search.FindRootMove\@:
                add  x2, x2, sizeof.RootMove
                ldr  w4, [x2, RootMove.pv + 4*0]
                cmp  w1, w4
                bne  Search.FindRootMove\@
                mov  w26, 1
                mov  w10, -VALUE_INFINITE
                ldr  w4, [sp, Search.moveCount]
                cmp  w26, w4
                beq  Search.FoundRootMove1\@
                ldr  w4, [sp, Search.alpha]
                cmp  w27, w4
                ble  Search.FoundRootMoveDone\@

                add  x6, x20, -Thread.rootPos
                ldr  d0, [x6, Thread.bestMoveChanges]
               fmov  d4, 1.0
               fadd  d0, d0, d4
                add  x6, x20, -Thread.rootPos
                str  d0, [x6, Thread.bestMoveChanges]

Search.FoundRootMove1\@:
                mov  w10, w27
                add  x6, x20, -Thread.rootPos
                ldr  w0, [x6, Thread.selDepth]
                ldr  x1, [x21, 1*sizeof.State + State.pv]
                str  w0, [x2, RootMove.selDepth]
                  b  Search.CopyRootPvw\@

Search.CopyRootPv\@:
                add  x1, x1, 4
                add  x6, x2, RootMove.pv
                str  w0, [x6, x26, lsl 2]
                add  w26, w26, 1
Search.CopyRootPvw\@:
                ldr  w0, [x1]
               cbnz  w0, Search.CopyRootPv\@
                str  w26, [x2, RootMove.pvSize]
Search.FoundRootMoveDone\@:
                str  w10, [x2, RootMove.score]
  .endif

        // check for new best move
                ldr  w1, [sp, Search.move]
                ldr  w4, [sp, Search.bestValue]
                cmp  w27, w4
                ble  Search.18NoNewBestValue\@
                str  w27, [sp, Search.bestValue]

                ldr  w4, [sp, Search.alpha]
                cmp  w27, w4
                ble  Search.18NoNewAlpha\@
                str  w1, [sp, Search.bestMove]

  .if (\PvNode == 1) && (\RootNode == 0)

                ldr  w1, [sp, Search.move]
                ldr  x8, [x21, 0*sizeof.State + State.pv]
                ldr  x9, [x21, 1*sizeof.State + State.pv]
                mov  w0, 0
                str  w1, [x8]
                add  x8, x8, 4
                cbz  x9, Search.pv_copy_end\@
Search.pv_copy_loop\@:
                ldr  w0, [x9]
                add  x9, x9, 4
Search.pv_copy_end\@:
                str  w0, [x8]
                add  x8, x8, 4
               cbnz  w0, Search.pv_copy_loop\@
  .endif

  .if \PvNode == 1
                ldr  w4, [sp, Search.beta]
                cmp  w27, w4
                bge  Search.18fail_high\@
                str  w27, [sp, Search.alpha]
                  b  Search.18NoNewBestValue\@
  .endif

Search.18fail_high\@:
                  b  Search.MovePickDone\@

Search.18NoNewAlpha\@:
Search.18NoNewBestValue\@:

                ldr  w1, [sp, Search.move]
                ldr  w0, [sp, Search.quietCount]
               ldrb  w4, [sp, Search.captureOrPromotion]
               cbnz  w4, Search.18Done\@
                ldr  w4, [sp, Search.bestMove]
                cmp  w1, w4
                beq  Search.18Done\@
                cmp  w0, 64
                bhs  Search.18Done\@        
                add  x6, sp, Search.quietsSearched
                str  w1, [x6, x0, lsl 2]

                add  w0, w0, 1
                str  w0, [sp, Search.quietCount]
Search.18Done\@:
                  b  Search.MovePickLoop\@


Search.MovePickDone\@:


        // Step 20. Check for mate and stalemate
                ldr  w0, [x21, -1*sizeof.State + State.currentMove]
                sub  w26, w0, 1
                and  w0, w0, 63
                add  x6, x20, Pos.board
               ldrb  w1, [x6, x0] 
                lsl  w1, w1, 6
                add  w25, w0, w1
                ldr  w22, [sp, Search.bestMove]
                ldr  w0, [sp, Search.depth]
                mov  w23, w0
                mul  w0, w0, w0
                add  w10, w0, w23, lsl 1
                sub  w10, w10, 2
                ldr  w24, [sp, Search.excludedMove]
        // w25 = offset of [piece_on(prevSq),prevSq]
        // w22 = move
        // w23 = depth
        // w10 = bonus
        // w24 = excludedMove
                ldr  w27, [sp, Search.bestValue]
                ldr  w4, [sp, Search.moveCount]
                cbz  w4, Search.20Mate\@
                cbz  w22, Search.20CheckBonus\@
Search.20Quiet\@:
                mov  w2, w22
                mov  w0, w22
                and  w0, w0, 63
                lsr  w2, w2, 14
                add  x6, x20, Pos.board
               ldrb  w0, [x6, x0]
                lea  x6, _CaptureOrPromotion_or
               ldrb  w4, [x6, x2]
                orr  w0, w0, w4
                lea  x6, _CaptureOrPromotion_and
               ldrb  w4, [x6, x2]
                tst  w0, w4
                bne  Search.20Quiet_SkipUpdateStats\@
                add  x3, sp, Search.quietsSearched
                ldr  w5, [sp, Search.quietCount]
        UpdateStats  w22, x3, 1, w5, w11, w10, x25

Search.20Quiet_SkipUpdateStats\@:

                add  w10, w10, w23, lsl 1
                add  w10, w10, 3
        // r10d = penalty
                ldr  w4, [x21, -1*sizeof.State + State.moveCount]
                cmp  w4, 1
                bne  Search.20TTStore\@
               ldrb  w4, [x21, State.capturedPiece]
               cbnz  w4, Search.20TTStore\@
                sub  w11, wzr, w10, lsl 5
                cmp  w10, 324
                bhs  Search.20TTStore\@
        UpdateCmStats  x21, -1*sizeof.State, x25, w11, w10, x8
                  b  Search.20TTStore\@

Search.20Mate\@:
                ldr  x0, [x21, State.checkersBB]
                ldr  w1, [x20, Pos.sideToMove]
               ldrb  w27, [x21, State.ply]
                mov  w4, VALUE_MATE
                sub  w27, w27, w4
                tst  x0, x0
                lea  x6, DrawValue
                ldr  w4, [x6, x1, lsl 2]
               csel  w27, w4, w27, eq
                tst  w24, w24
                ldr  w4, [sp, Search.alpha]
               csel  w27, w4, w27, ne
                  b  Search.20TTStore\@
Search.20CheckBonus\@:
        // we already checked that bestMove = 0
                sub  w2, w23, 3*ONE_PLY
                orr  w2, w2, w26
               tbnz  w2, 31, Search.20TTStore\@
               ldrb  w4, [x21, State.capturedPiece]
               cbnz  w4, Search.20TTStore\@

                lsl  w11, w10, 5
                cmp  w10, 324
                bhs  Search.20TTStore\@
      UpdateCmStats  x21, -1*sizeof.State, x25, w11, w10, x8

Search.20TTStore\@:
        // edi = bestValue
                ldr  x9, [sp, Search.posKey]
                mov  w4, VALUE_MATE_IN_MAX_PLY
                add  w1, w27, w4
                ldr  x8, [sp, Search.tte]
                lsr  x9, x9, 48
                mov  w2, w27
               cbnz  w24, Search.ReturnBestValue\@
                mov  w4, VALUE_MATE_IN_MAX_PLY
                cmp  w1, w4, lsl 1
                bhs  Search.20ValueToTT\@
Search.20ValueToTTRet\@:
 .if \PvNode == 0
                ldr  w0, [sp, Search.bestMove]
                ldr  w4, [sp, Search.beta]
                cmp  w27, w4
               cset  w26, ge
                add  w26, w26, BOUND_UPPER
 .else
                ldr  w0, [sp, Search.bestMove]
                mov  w1, BOUND_LOWER
                cmp  w0, 1
              csetm  w26, lo
                mov  w4, BOUND_EXACT
                add  w26, w4, w26, lsl 1
                ldr  w4, [sp, Search.beta]
                cmp  w27, w4
               csel  w26, w1, w26, ge
 .endif
               ldrb  w3, [sp, Search.depth]
               ldrh  w7, [x21, State.staticEval]
                MainHash_Save Search.ltte, x8, w9, w2, w26, w3, w0, w7
Search.ReturnBestValue\@:
                mov  w0, w27

Search.Return\@:

Display 2, "Search returning %i0\n"

                add  sp, sp, Search.localsize
                ldp  x29, x30, [sp], 16
                ldp  x27, x28, [sp], 16
                ldp  x25, x26, [sp], 16
                ldp  x23, x24, [sp], 16
                ldp  x21, x22, [sp], 16
                ret


Search.ValueFromTT\@:
               ldrb  w8, [x21, State.ply]
                asr  w9, w27, 31
                eor  w8, w8, w9
                add  w27, w27, w9
                sub  w27, w27, w8
                  b  Search.ValueFromTTRet\@

Search.IllegalMove\@:
                ldr  w0, [sp, Search.moveCount]
                sub  w0, w0, 1
                str  w0, [x21, State.moveCount]
                str  w0, [sp, Search.moveCount]
                  b  Search.MovePickLoop\@

  .if \RootNode == 0
Search.AbortSearch_PlyBigger\@:
                ldr  x1, [x21, State.checkersBB]
                ldr  w0, [x20, Pos.sideToMove]
                lea  x6, DrawValue
                ldr  w0, [x6, x0, lsl 2]
                cbz  x1, Search.Return\@
                 bl  Evaluate
                  b  Search.Return\@

Search.AbortSearch_PlySmaller\@:
                ldr  w0, [x20, Pos.sideToMove]
                lea  x6, DrawValue
                ldr  w0, [x6, x0, lsl 2]
                  b  Search.Return\@
  .endif

  .if \PvNode == 0

Search.ReturnTTValue\@:
        // edi = ttValue
                mov  w22, w1
                ldr  w0, [sp, Search.depth]
                mov  w23, w0
                mul  w0, w0, w0
                add  w10, w0, w23, lsl 1
                sub  w10, w10, 2
        // r12d = move
        // r13d = depth
        // r10d = bonus

                and  w2, w22, 63
                lsr  w0, w22, 14
                add  x6, x20, Pos.board
               ldrb  w2, [x6, x2]
                lea  x6, _CaptureOrPromotion_or
               ldrb  w4, [x6, x0]
                orr  w2, w2, w4
                lea  x6, _CaptureOrPromotion_and
               ldrb  w4, [x6, x0]
                and  w2, w2, w4
        // dl = capture or promotion

                mov  w0, w27
                cbz  w1, Search.Return\@

        // ttMove is quiet; update move sorting heuristics on TT hit
                ldr  w4, [sp, Search.beta]
                cmp  w27, w4
                blt  Search.ReturnTTValue_Penalty\@

                ldr  w0, [x21, -1*sizeof.State + State.currentMove]
                and  w0, w0, 63
                add  x6, x20, Pos.board
               ldrb  w1, [x6, x0]
                lsl  w1, w1, 6
                add  w25, w0, w1
        // r15d = offset of [piece_on(prevSq),prevSq]

               cbnz  w2, Search.ReturnTTValue_SkipUpdateStats\@
        UpdateStats  w22, 0, 0, 0, w11, w10, x25

Search.ReturnTTValue_SkipUpdateStats\@:

                mov  w0, w27
                add  w10, w10, w23, lsl 1
                add  w10, w10, 3
        // r10d = penalty
                ldr  w4, [x21, -1*sizeof.State + State.moveCount]
                cmp  w4, 1
                bne  Search.Return\@
               ldrb  w4, [x21, State.capturedPiece]
               cbnz  w4, Search.Return\@
                sub  w11, wzr, w10, lsl 5
                cmp  w10, 324
                bhs  Search.Return\@
      UpdateCmStats  x21, -1*sizeof.State, x25, w11, w10, x8

                mov  w0, w27
                  b  Search.Return\@

Search.ReturnTTValue_Penalty\@:

                and  w1, w1, 64*64 - 1
                ldr  w8, [x20, Pos.sideToMove]
                lsl  w8, w8, 14
                ldr  x4, [x20, Pos.history]
                add  x8, x8, x4
                add  x8, x8, x1, lsl 2
        // r8 = offset in history table

               cbnz  w2, Search.Return\@
                sub  w11, wzr, w10, lsl 5
                cmp  w10, 324
                bhs  Search.Return\@

                ldr  w0, [x8]
                mov  w1, 324
         ApplyBonus  w0, w2, w11, w10, w1
                str  w0, [x8]

                and  w9, w22, 63
               ubfx  w0, w22, 6, 6
                add  x6, x20, Pos.board
               ldrb  w0, [x6, x0]
                add  w9, w9, w0, lsl 6
        // r9 = offset in cm table
      UpdateCmStats  x21, -0*sizeof.State, x9, w11, w10, x8

                mov  w0, w27
                  b  Search.Return\@
 .endif

Search.20ValueToTT\@:
               ldrb  w2, [x21, State.ply]
                asr  w0, w27, 31
                eor  w2, w2, w0
                sub  w2, w2, w0
                add  w2, w2, w27
                  b  Search.20ValueToTTRet\@

  .if \RootNode == 0
Search.CheckDraw_Cold\@:
      PosIsDraw_Cold  Search.AbortSearch_PlySmaller\@, Search.CheckDraw_ColdRet\@
  .endif


  .if USE_CURRMOVE
    .if VERBOSE < 2
      .if \RootNode == 1
Search.PrintCurrentMove\@:
                lea  x6, options
               ldrb  w4, [x6, Options.displayInfoMove]
                cbz  w4, Search.PrintCurrentMoveRet\@

                lea  x27, [Output]
                ldr  w0, [sp, Search.depth]
                ldr  w1, [sp, Search.move]
                ldr  w2, [sp, Search.moveCount]
                add  x4, x20, -Thread.rootPos
                ldr  w4, [x4, Thread.PVIdx]
                add  w2, w2, w4
                stp  x2, x2, [sp, -16]!
                stp  x0, x1, [sp, -16]!
                lea  x1, sz_format_currmove
                mov  x2, sp
                mov  x3, 0
                 bl  PrintFancy
                add  sp, sp, 8*4
                 bl  Os_WriteOut_Output

                  b  Search.PrintCurrentMoveRet\@
      .endif
    .endif
  .endif
.endm
