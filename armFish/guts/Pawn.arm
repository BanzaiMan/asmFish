.macro EvalPawns Us
	// in  rbp address of Pos struct
	//     rbx address of State struct
	//     rdi address of pawn table entry
	// out esi score
  .if \Us == White
        Them  = Black
        Up    = DELTA_N
        Right = DELTA_NE
        Left  = DELTA_NW
  .else
        Them  = White
        Up    = DELTA_S
        Right = DELTA_SW
        Left  = DELTA_SE
  .endif
	Isolated0   = ((45 << 16) + (40))
	Isolated1   = ((30 << 16) + (27))
	Backward0   = ((56 << 16) + (33))
	Backward1   = ((41 << 16) + (19))
	Unsupported = ((17 << 16) + (8))
	Doubled     = ((18 << 16) + (38))
        
                mov  w0, 0
                str  x0, [x27, PawnEntry.passedPawns + 8*\Us]
                str  x0, [x27, PawnEntry.pawnAttacksSpan + 8*\Us]
                mov  w4, 64
               strb  w4, [x27, PawnEntry.kingSquares + \Us]
                mov  w4, 255
               strb  w4, [x27, PawnEntry.semiopenFiles + \Us]

                ldr  x25, [x20, Pos.typeBB + 8*Pawn]
                mov  x24, x25
                ldr  x4, [x20, Pos.typeBB + 8*Them]
                and  x24, x24, x4
                ldr  x4, [x20, Pos.typeBB + 8*\Us]
                and  x25, x25, x4
                mov  x23, x25
        // r14 = their pawns
        // r13 = our pawns     = r15

            ShiftBB  Right, x0, x25
            ShiftBB  Left, x2, x25
                orr  x0, x0, x2
                str  x0, [x27, PawnEntry.pawnAttacks + 8*\Us]

              mov64  x0, LightSquares
                and  x0, x0, x25
             Popcnt  x0, x0, x1
              mov64  x2, DarkSquares
                and  x2, x2, x25
             Popcnt  x2, x2, x1
               strb  w0, [x27, PawnEntry.pawnsOnSquares + 2*\Us + White]
               strb  w2, [x27, PawnEntry.pawnsOnSquares + 2*\Us + Black]

                mov  w26, 0
        // esi = score

                cbz  x25, EvalPawns.AllDone\@


                add  x25, x20, Pos.pieceList + 16*(8*\Us + Pawn)
               ldrb  w1, [x20, Pos.pieceList + 16*(8*\Us + Pawn)]
EvalPawns.NextPiece\@:
                add  x25, x25, 1


                and  w2, w1, 7
                lsr  w22, w1, 3
 .if \Us == Black
                eor  w22, w22, 7
 .endif
        // w1 = s, w2 = f, w22 = relative_rank(Us, s)

               ldrb  w0, [x27, PawnEntry.semiopenFiles + \Us]
                mov  w4, 1
                lsl  w4, w4, w2
                bic  w0, w0, w4
               strb  w0, [x27, PawnEntry.semiopenFiles + \Us]
                lea  x6, PawnAttackSpan + 8*(64*\Us)
                ldr  x0, [x6, x1, lsl 3]
                ldr  x4, [x27, PawnEntry.pawnAttacksSpan + 8*\Us]
                orr  x4, x4, x0
                str  x4, [x27, PawnEntry.pawnAttacksSpan + 8*\Us]

        // w11 = opposed
                lea  x6, ForwardBB + 8*(64*\Us)
                ldr  x11, [x6, x1, lsl 3]
                tst  x11, x24
              csetm  w11, ne
        // x2 = adjacent_files_bb(f)
                lea  x6, AdjacentFilesBB
                ldr  x2, [x6, x2, lsl 3]
        // x10 = stoppers
                lea  x6, PassedPawnMask + 8*(64*\Us)
                ldr  x10, [x6, x1, lsl 3]
                and  x10, x10, x24
                lsr  w8, w1, 3
                lea  x6, RankBB - Up
                ldr  x8, [x6, x8, lsl 3]
        // x9 = neighbours
                and  x9, x23, x2
        // x8 = supported
                and  x8, x8, x9
        // doubled is taken care of
                sub  w0, w1, Up
                mov  x4, 1
                lsl  x4, x4, x0
                tst  x4, x23
               ccmp  x8, xzr, 0, ne
              mov32  w4, Doubled
                sub  w4, w26, w4
               csel  w26, w4, w26, eq
                lea  x6, PawnAttacks + 8*(64*\Us)
                ldr  x0, [x6, x1, lsl 3]
                cbz  x9, EvalPawns.Neighbours_False\@

EvalPawns.Neighbours_True\@:

        // x0 = lever
               ands  x0, x0, x24
                lea  x6, Lever
                ldr  w4, [x6, x22, lsl 2]
               csel  w0, w4, w0, ne
                add  w26, w26, w0
                bne  EvalPawns.TestUnsupported\@

EvalPawns.Lever_False\@:

                orr  x0, x9, x10
  .if \Us == White
                cmp  w1, SQ_A5
                bhs  EvalPawns.TestUnsupported\@
  .else
                cmp  w1, SQ_A5
                blo  EvalPawns.TestUnsupported\@
  .endif
  .if \Us == White
               rbit  x0, x0
                clz  x0, x0
  .else
                clz  x0, x0
                eor  x0, x0, 63
  .endif
                lsr  w0, w0, 3
                lea  x6, RankBB
                ldr  x0, [x6, x0, lsl 3]
                and  x2, x2, x0
            ShiftBB  Up, x2, x2
                orr  x2, x2, x0
              mov32  w4, Backward0
              mov32  w5, Backward1
                sub  w0, w4, w5
                and  w0, w0, w11
                sub  w0, w0, w4
                add  w0, w0, w26
                tst  x2, x10
               csel  w26, w0, w26, ne
                bne  EvalPawns.Continue\@

EvalPawns.TestUnsupported\@:
                tst  x8, x8
              mov32  w4, Unsupported
                sub  w4, w26, w4
               csel  w26, w4, w26, eq
                  b  EvalPawns.Continue\@

EvalPawns.Neighbours_False\@:

               ands  x0, x0, x24
                lea  x6, Lever
                ldr  w4, [x6, x22, lsl 2]
               csel  w0, w4, w0, ne
                add  w26, w26, w0

              mov32  w4, Isolated0
              mov32  w5, Isolated1
                sub  w0, w4, w5
                and  w0, w0, w11
                sub  w26, w26, w4
                add  w26, w26, w0

EvalPawns.Continue\@:
        // at this point we have taken care of
        //       backwards, neighbours, supported, lever

                neg  w11, w11
                lsr  w2, w1, 3
                lea  x6, RankBB
                ldr  x2, [x6, x2, lsl 3]
                and  x2, x2, x9
        // x9 = popcnt(phalanx)
             Popcnt  x9, x2, x0
                tst  x2, x2
               cinc  w4, w11, ne
                add  w11, w11, w4
                sub  x0, x8, 1
               ands  x0, x0, x8
               cinc  w4, w11, ne
                add  w11, w11, w4
                add  w11, w22, w11, lsl 3
                orr  x2, x2, x8
                tst  x2, x2
                lea  x6, Connected
                ldr  w4, [x6, x11, lsl 2]
               csel  w2, w4, w2, ne

        // connected is taken care of
                add  w26, w26, w2
        // x8 = supported
        // x11 = popcnt(supported)
             Popcnt  x11, x8, x0

                lea  x6, PawnAttacks + 8*(64*\Us)
                ldr  x0, [x6, x1, lsl 3]
        // x0 = lever
                and  x0, x0, x24
                lea  x6, PawnAttacks + 8*(64*\Us + Up)
                ldr  x2, [x6, x1, lsl 3]
                and  x2, x2, x24
        // x2 = leverPush

                mov  x22, x10

                lea  x6, ForwardBB + 8*(64*\Us)
                ldr  x4, [x6, x1, lsl 3]
                tst  x23, x4
                bne  EvalPawns.NoPassed\@
                eor  x10, x10, x0
                eor  x10, x10, x2
               cbnz  x10, EvalPawns.NoPassed\@
             Popcnt  x0, x0, x10
             Popcnt  x2, x2, x10
                cmp  w11, w0
               ccmp  w9, w2, 0, cs
                bcc  EvalPawns.NoPassed\@
                mov  x0, 1
                lsl  x0, x0, x1
                ldr  x4, [x27, PawnEntry.passedPawns + 8*\Us]
                orr  x4, x4, x0
                str  x4, [x27, PawnEntry.passedPawns + 8*\Us]
                  b  EvalPawns.Done\@        

EvalPawns.NoPassed\@:

                add  w0, w1, Up
                mov  x4, 1
                lsl  x4, x4, x0
                eor  x22, x22, x4
  .if \Us == White
                lsl  x8, x8, 8
                cmp  w1, SQ_A5
                blo  EvalPawns.Done\@
  .else
                lsr  x8, x8, 8
                cmp  w1, SQ_A5
                bhs  EvalPawns.Done\@
  .endif
               cbnz  x22, EvalPawns.Done\@
               bics  x8, x8, x24
                beq  EvalPawns.Done\@

EvalPawns.PopLoop\@:

               rbit  x9, x8
                clz  x9, x9
                lea  x6, PawnAttacks + 8*(64*\Us)
                ldr  x9, [x6, x9, lsl 3]
                and  x9, x9, x24
                sub  x2, x9, 1
               ands  x2, x2, x9
               cset  w0, eq
                lsl  x0, x0, x1
                ldr  x4, [x27, PawnEntry.passedPawns + 8*\Us]
                orr  x4, x4, x0
                str  x4, [x27, PawnEntry.passedPawns + 8*\Us]
                sub  x0, x8, 1
                and  x8, x8, x0
               cbnz  x8, EvalPawns.PopLoop\@

EvalPawns.Done\@:

               ldrb  w1, [x25]
                cmp  w1, 64
                blo  EvalPawns.NextPiece\@

EvalPawns.AllDone\@:

.endm
