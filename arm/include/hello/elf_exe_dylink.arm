include 'format/format.inc'
format ELF64 executable 0
entry Start


macro balign boundary
    local size
    size = (boundary-1)-($+boundary-1) mod boundary
	db (size mod 4) dup 0
    dd (size  /  4) dup 0xd503201f
end macro


; some comments on ld-linux-aarch64.so.1:
;
; - Does require the program headers to be contained in a load command.
;       Throws a failed assert if not:
;           Inconsistency detected by ld.so: rtld.c: 1290: dl_main: Assertion `_rtld_local._dl_rtld_map.l_libname' failed!
;       This seems to be a bug. For this reason format.inc now has
;           ELF.Settings.LoadHeaders = 1
; - Does require the dynamic segment to be contained in another load segment.
;       Throws a segmentation fault if not. This seems to be another bug.
;       For this reason, the "segment" macro in elfexe.inc has been extended
; - Does not require the interpreter segment to be contained in another load segment.
;       It is in this example, but the commented out segment works fine too.


segment readable executable 

segment { interpreter readable 
    db '/lib/ld-linux-aarch64.so.1',0
segment }

         balign  4      ; instruction addresses should be divisible by 4
Start:
            mov  x0, 1
            adr  x1, Test
            mov  x2, TestEnd - Test
            mov  x8, 64
            svc  0

            mov  x0, 1
            adr  x1, Message
            mov  x2, MessageEnd - Message
            ldr  x8, write      ; if the address of write is too far away, another method of loading it is required
            blr  x8

            mov  x0, 0
            ldr  x8, exit       ; ditto for exit
            blr  x8


;segment interpreter readable 
;    db '/lib/ld-linux-aarch64.so.1',0


segment readable writeable

          align  8      ; alignment not necessary
segment { dynamic readable writeable

    dq DT_NEEDED,  _libc-strtab 
    dq DT_STRTAB,  strtab 
    dq DT_STRSZ,   strsz 
    dq DT_SYMTAB,  symtab 
    dq DT_SYMENT,  sizeof.Elf64_Sym 
    dq DT_RELA,    rela 
    dq DT_RELASZ,  relasz 
    dq DT_RELAENT, sizeof.Elf64_Rela 
    ;dq DT_REL,     rel                 ; Not necessary if empty.
    ;dq DT_RELSZ,   relsz               ; (eventhough "rel" is claimed to be
    ;dq DT_RELENT,  sizeof.Elf64_Rela   ; manditory by the standard)
    dq DT_HASH,    hash 
    dq DT_NULL,    0 
segment }

          align  64
write:  dq 0
exit:   dq 0


symtab: 
    Elf64_Sym 0,               0, 0, 0,          0,        0, 0
    Elf64_Sym _write - strtab, 0, 0, STB_GLOBAL, STT_FUNC, 0, 0
    Elf64_Sym _exit  - strtab, 0, 0, STB_GLOBAL, STT_FUNC, 0, 0

rela:
    Elf64_Rela write, 1, R_AARCH64_ABS64, 0
    Elf64_Rela exit,  2, R_AARCH64_ABS64, 0
relasz = $ - rela 

rel:
relsz = $ - rel



hash: 
    dd 1, 3     ; size of bucket and size of chain 
    dd 0        ; fake bucket, just one hash value 
    repeat 3
        dd %    ; chain for all symbol table entries 
    end repeat

Test:
    db '1 Hello World!', 10
TestEnd:
Message:
    db '2 Hello World!', 10
MessageEnd:

strtab: 
    _null   db 0 
    _libc   db 'libc.so.6',0 
    _write  db 'write',0 
    _exit   db 'exit',0 
strsz = $ - strtab 



